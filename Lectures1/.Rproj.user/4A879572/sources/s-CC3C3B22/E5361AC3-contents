#==========================================#
# Elaborado por: Eduard F Martinez-Gonzalez
# Update: 17-03-2022
# R version 4.1.1 (2021-08-10)
#==========================================#

# initial configuration
rm(list=ls())
require(pacman) # require pacman
p_load(tidyverse,rio,sf,leaflet,png,grid,tidycensus,viridis, # require and/or install packages
       osmdata, # API Open Street Maps
       ggmap,   # API Google Maps
       ggsn,    # Barras de escalas
       gstat,   # Estimate semivariogram
       gtools)  # Funcion quantcut

#==== Hoy veremos ====# 

## 1. Plotting Simple Features
## 2. Semivariogram
## 3. OpenStreetMap
## 4. Google Maps
## 5. Manipulating Simple Feature Geometries
## 6. Aplications

#===============================#
# [1.] Plotting Simple Features #
#===============================#

# load data
boston = import("input/Boston (block group).rds") # get_acs(geography="block group" , variables="B25077_001" , state="MA" , county="Suffolk County" , year=2019 , geometry = T)
cbd = import("input/CBD Boston.rds") # st_as_sf(x=read.table(text="-71.057083  42.361145"), coords=c(1,2), crs=4326) %>% st_transform(crs=st_crs(boston))
amenities = import("input/Boston banks and restaurants.rds") # From OMS API

# plot basic map
ggplot() + 
geom_sf(data=boston, col="orange" , fill=NA , size=0.3) 

p = ggplot() + 
    geom_sf(data=boston, col="black" , aes(fill=estimate) , size=0.3)  +
    scale_fill_viridis(option="C" , alpha=0.9 , direction=-1 , name="MHV (Dollars)")
p

# Add layers 
p = p + 
    geom_sf(data=cbd, col="green" , size=5)  + 
    geom_sf(data=amenities,size=1,aes(col=amenity))
p

# add theme
p = p + 
    theme_bw()
p 

# add scalebar and north symbol
p = p + 
    north(data=boston , location="topleft") + 
    scalebar(data=boston , dist=5 , dist_unit="km" , transform=T , model="WGS84")
p

# remove axis-labels
p = p + 
    labs(x="",y="",color="Amenities")
p

# save plot
ggsave(plot=p , filename="output/map_boston.pdf" , width=6.5 , height=8)

#====================#
# [2.] Semivariogram #
#====================#

# Load data
bog = import("input/Median Housing Values Bogota.rds")

#=== 2.1. Motivation ===#

# ramdon vs correlation
dev.off()
grid.raster(readPNG("input/pics/motivation.png"))

# semivariogram
dev.off()
grid.raster(readPNG("input/pics/variograma.png"))

#=== 2.2. Basic plot ===#

# MHV en millones
bog$mhv = bog$mhv/1000000 

# gen normal distribution variable
set.seed(12345)
bog$normal = rnorm(n = nrow(bog),
                      mean = mean(bog$mhv),
                      sd = 660) 

# gen quantiles values
bog$mhv_q = quantcut(bog$mhv)
bog$normal_q = quantcut(bog$normal)

# Map A
ggplot() + 
geom_sf(data=bog , col=NA , aes(fill=mhv_q)) + 
scale_fill_manual(values=c("yellow","#FF9900","#FF6600","#CC0000","#990000"),na.value="white", name="Median Housing \nValues") + 
theme_bw() + 
north(data = bog , location ="topleft") + 
ggtitle("Map A")
ggsave("output/map_a.pdf")

# Map B
ggplot() + 
geom_sf(data=bog , col=NA, aes(fill=normal_q)) + 
scale_fill_manual(values=c("yellow","#FF9900","#FF6600","#CC0000","#990000"),na.value="white", name="Var. Random") + 
theme_bw() + 
north(data = bog , location ="topleft") + 
ggtitle("Map B")
ggsave("output/map_b.pdf")

#=== 2.3. Semivariogram ===#

# Semivariogram calculation
dev.off()
grid.raster(readPNG("input/pics/vario_equation.png")) # Aplied Spatial Data in R

## h = distancia
## Z(s) = Valor de la variable aleatorio para la ubicacion s

# variograms
variogram(mhv ~ 1, data = bog, cloud = F , cressie=T) %>% plot()
cat("En el caso de observaciones atípicas, los valores extremos de nubes de variogramas se identifican 
     fácilmente para encontrar los valores atípicos. Es posible que sea necesario eliminarlos o, 
     de lo contrario, se pueden calcular medidas sólidas para el variograma de muestra pasando el 
     argumento lógico cressie = TRUE a la llamada a la función del variograma (Cressie, 1993).")

sv_value = variogram(mhv ~ 1, bog, cloud = F , cressie=T) %>% select(dist,gamma) %>% mutate(variable="MHV")
sv_value
sv_normal = variogram(normal ~ 1, bog, cloud = F , cressie=T) %>% select(dist,gamma) %>% mutate(variable="D. Normal")
sv_normal
db = bind_rows(sv_value,sv_normal) 
db

## Plot
ggplot() + 
geom_point(data=db , aes(x=dist, y=gamma , fill=variable), shape=21, alpha=0.5, size=5 ) +
labs(y = "Gamma", x = "Distancia de separación entre manzanas", fill = "") + theme_bw()
ggsave("input/pics/variograma.png", height=5 , width=8)

# clean environment
rm(db,sv_normal,sv_value)

#====================#
# [3.] OpenStreetMap #
#====================#

#=== 3.1. About OMS ===#

# view keys
browseURL("https://wiki.openstreetmap.org/wiki/Map_features")

# get avaliables values for amenity
available_tags("amenity")
available_tags("building")
available_tags("landuse")

# get bbox
getbb("Bogotá Colombia")

#=== 3.2. Get amenities ===#

# get osm data
osm = opq(bbox = getbb("Bogotá Colombia")) %>%
      add_osm_feature(key = "amenity", value = "bar") %>%
      #add_osm_feature(key = "amenity", value = "bus_station") %>%
      #add_osm_feature(key = "amenity", value = "restaurant") %>%
      osmdata_sf()
osm %>% class()
osm

# get sf object
amenities = osm$osm_points %>% select(osm_id,amenity)

# plot data
leaflet() %>% 
addTiles() %>% 
addCircleMarkers(data=amenities , weight=1 , col="green")


#=== 3.3. Get street ===#

# get osm data
street = opq(bbox = getbb("Bogotá Colombia")) %>%
         add_osm_feature(key = "highway") %>%
         osmdata_sf()

# get sf object
street = street$osm_lines %>% select(osm_id,name)
street = street %>%
         subset(str_detect(name,"Avenida")==T | str_detect(name,"TransMilenio")==T)

#==================#
# [4.] Google Maps #
#==================#

# You can get the Google key here: https://developers.google.com/maps/documentation/geocoding/get-api-key?hl=es
#register_google(key = "Write the appy key here" , write = T) 

# Geocode 
google = geocode(location="Universidad , Bogotá D.C.",
                 output="latlon",
                 source="google")
google

google = st_as_sf(x = google , coords=c("lon","lat") , crs=4326)
google$name = "Universidad de los Andes"

leaflet() %>%
addTiles() %>%
addCircleMarkers(data=google)

# load data 
ips = import("input/IPS Bogota.rds") %>% 
      subset(is.na(lon_google)==F)
ips = st_as_sf(x=ips , coords=c("lon_google","lat_google"), crs=4326) 

# view data
leaflet() %>%
addTiles() %>%
addCircleMarkers(data=ips , label=ips$nombre_prestador)

#=============================================#
# [5.] Manipulating Simple Feature Geometries #
#=============================================#

## Help
vignette("sf3")

# get boundary
layer = opq(bbox = getbb("Bogotá Colombia")) %>%
        add_osm_feature(key = "boundary", value = "administrative") %>% osmdata_sf()
layer = layer$osm_multipolygons %>% subset(admin_level==9) %>% select(osm_id,name)
layer

#=== 5.1 Affine transformations ===#

# change crs
layer = st_transform(layer , crs = st_crs(bog))
ips = st_transform(ips , crs = st_crs(bog))
amenities = st_transform(amenities , crs = st_crs(bog))
street = st_transform(street , crs = st_crs(bog))

#=== 5.2 Cliping data ===#

# cliping
ips_1 = st_crop(ips,layer) # Option 1 
ips_2 = st_intersection(ips,layer) # Option 2
ips = ips[layer,] # Option 3

# view data
leaflet() %>%
addTiles() %>%
addCircleMarkers(data=ips , label=ips$nombre_prestador)

#=== 5.3 Centroid ===#

# change geometry
point = st_centroid(x = bog , of_largest_polygon = T)

#=== 5.4 Buffer ===#

# Buffer
#buff = st_buffer(x = point , dist = 200)
buff = st_read("input/a.gpkg") %>% select(MANZ_CCNCT)
  
# view data
leaflet() %>%
addTiles() %>%
addPolygons(data=buff[1,]) %>%
addCircleMarkers(data=point,col="red")

#=== 5.5 Join spatial ===#

# Add MHV neighborhood
buff = st_join(buff,point)

st_geometry(buff) = NULL

buff = buff %>% 
       group_by(MANZ_CCNCT) %>%
       summarise(n_mhv = mean(mhv))
       
#=== 5.6 Distances ===#

# distance to ips
dist_ips = st_distance(point,ips)
min_dist_ips = apply(X = dist_ips , MARGIN = 1 , mean)
point$dist_ips = min_dist_ips

# distance to amenities
dist_ameni = st_distance(point,amenities)
min_dist_ameni = apply(X = dist_ameni , MARGIN = 1 , min)
point$dist_ameni = min_dist_ameni

# distance to main street  
dist_street = st_distance(point,street)
min_dist_street = apply(X = dist_street , MARGIN = 1 , min)
point$dist_street = min_dist_street

#==================#
# [6.] Aplications #
#==================#

#=== 6.1 Join data ===#
st_geometry(point) = NULL
point = point %>% select(MANZ_CCNCT,mhv,dist_ips,dist_ameni,dist_street)

df = left_join(point,buff,"MANZ_CCNCT") %>% as_tibble()
df

# export data
export(df,"output/data regressions.rds")

#=== 6.2 Estimations ===#

# OLS
lm(mhv ~ dist_ips + dist_ameni + n_mhv + dist_street, data = df) %>% summary()

# export 
st_write(bog,"output/Bogota MHV.shp")

#=====================#
# Para seguir leyendo #
#=====================#

##  Lovelace, R., Nowosad, J., & Muenchow, J. (2019). Geocomputation with R. [Ver aquí]

    # Cap. 4: Spatial Data Operations
    # Cap. 5: Geometry Operations
    # Cap. 6: Reprojecting geographic data
    # Cap. 11: Statistical learning

## Bivand, R. S., Pebesma, E. J., Gómez-Rubio, V., & Pebesma, E. J. (2013). Applied spatial data analysis with R. [Ver aquí]

    # Cap. 7: Spatial Point Pattern Analysis
    # Cap. 8: Interpolation and Geostatistics






